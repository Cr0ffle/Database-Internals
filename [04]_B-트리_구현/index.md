# #4 B-트리 구현

## 페이지 헤더

- 페이지 헤더에는 탐색과 유지보수, 최적화에 필요한 페이지에 대한 정보를 저장한다.
- 일반적으로 플래그와 레이아웃, 셀 개수, 오프셋과 같은 몇가지 유용한 메타데이터를 저장한다.
  - MySQL InnoDB는 힙 레코드 개수와 레벨을 저장
  - PostgreSQL은 페이지 크기와 레이아웃 버전을 헤더에 저장
  - SQLite는 셀 개수와 가장 오른쪽 포인터를 저장




### 매직 넘버

- 파일 헤더 또는 페이지 헤더에 주로 저장하는 또 다른 값으로 매직 넘버가 있다.
- 일반적으로 매직 넘버는 상수 값을 포함하는 멀티바이트 블록이며 페이지의 종류와 버전과 같은 정보를 포함한다.
- 매직넘버는 검증과 상태체크에도 사용된다.

### 형제 링크

- 좌우에 있는 형제 페이지를 가리키도록 순방향 링크와 역방향 링크를 저장하는 방식으로 트리를 구현하기도 한다.
- 약간의 복잡도가 증가하긴 하지만 이렇게 하면 부모 노드로 거슬러 올라가지 않고 이웃 노드를 바로 참조할 수 있다.
- 하지만 형제링크가 없는 트리에서 형제 노드를 찾으려면 반드시 부모 노드를 거쳐야 하는 오버헤드가 있다. 헤더에 형제 링크를 저장하면 같은 레벨의 이전 노드나 다음 노드에 빠르게 접근할 수 있다.

![4-1](https://github.com/sup2is/dev-note/raw/master/db//images/database-internals/4-1.jpeg)

- 이 방법의 단점은 노드 분할과 병합 시 링크를 업데이트해야 한다는 점이다. 분할과 병합의 대상 노드 뿐만 아니라 형제 노드까지 업데이트하기 위해 추가적으로 잠금이 필요할 수 있다.





### 가장 오른쪽 포인터

- B-트리의 구분 키의 주 역할은 트리를 서브트리로 분할하고 탐색할 수 있도록 하는 것이다. 따라서 자식 페이지를 가리키는 포인터가 키보다 반드시 하나 더 있다.
- 각 구분 키에는 자식 포인터가 있고 마지막 포인터는 어떤 키와도 연관되지 않기 때문에 따로 저장한다.

![4-2](https://github.com/sup2is/dev-note/raw/master/db//images/database-internals/4-2.jpeg)

- 가장 오른쪽 자식 노드가 분할되고 부모에 새로운 셀이 추가되면 부모의 마지막 포인터도 다시 설정해야 한다.
- 노드 분할 시 마지막 포인터는 새로운 노드를 가리키도록 업데이트 된다.

![4-3](https://github.com/sup2is/dev-note/raw/master/db//images/database-internals/4-3.jpeg)

- SQLite가 이와 유사한 방식으로구현돼 있다.



### 하이 키

- 각 트리의 노드의 가장 오른쪽포인터와 노드의 하이 키를 함께 저장하는 방법도 있다.
- 하이 키는 현재 노드의 서브트리에 저장된 가장 큰 키를 나타낸다. 이런 형식을 Blink-트리라고 부르며 PostgreSQL에서 사용된다.
- Blink-트리는 각 노드에 Kn+1 키를 하나씩 더 추가로 저장한다. 이 키는 포인터 Pn이 가리키는 서브트리에서 가장 큰 키를 나타낸다. 따라서 이 키 값이 해당 서브트리에 저장할 수 있는 최댓값이 된다.

![4-4](https://github.com/sup2is/dev-note/raw/master/db//images/database-internals/4-4.jpeg)

- 하이 키를 저장하는 트리는 각 노드에 저장된 키와 포인터 개수가 같으며 모든 셀에는 키-포인터 쌍이 존재한다. 이에 따라 엣지 케이스가 줄어들고 가장 오른쪽 포인터의 처리가 단순해진다.
- 첫번째 방식에서 최댓값은 +⚯ 이지만 두번째 방식은 K3으로 줄어든다.

![4-5](https://github.com/sup2is/dev-note/raw/master/db//images/database-internals/4-5.jpeg)



### 오버플로우 페이지

- 노드의 크기와 트리 팬아웃은 고정 값이며 동적으로 변하지 않는다. 하지만 모든 상황에 적합한 최적의 값을 찾기는 쉽지 않다.
- B-트리 알고리즘에서 모든 노드는 일정 개수의 키를 유지해야하지만 노드에 저장된 값의 크기가 크다면 개수가 가득차지 않더라도 고정 크기의 페이지에는 남은 공간이 없을 수 있다. 페이지 변경을 하는건 비효율적이지만 페이지 크기 증가 및 확장은 불가피하다.
- 여러 페이지를 연결하면 데이터를 다른 연속된 공간으로 복사하지 않고 가변 크기 노드를 구현할 수 있다. 예를 들어 기본 크기가 4K인 페이지에 삽입된 값의 합이 4K 이상이면 임의의 크기를 추가 할당하지 않고 4K 단위로 노드를 확장하고 할당된 새로운 페이지를 원본 페이지에 연결하면 된다. 이렇게 새로 할당된 페이지를 오버플로우 페이지라고 한다.
- 대부분의 B-트리는 고정 크기의 바이트만 노드에 저장하고 나머지는 오버플로우 페이지에 저장한다.
- 고정 크기는 노드 크기를 팬아웃으로 나눈 값이다. 따라서 페이지에 최소 max_payload_byte 바이트 만큼의 공간이 항상 남아 있기 때문에 페이지에 공간이 부족한 상황은 발생하지 않는다.
- 삽입된 데이터가 max_payload_size보다 크다면 해당 노드에 연결된오버플로우 페이지가 있는지 확인해야 한다.

![4-6](https://github.com/sup2is/dev-note/raw/master/db//images/database-internals/4-6.jpeg)

- 오버 플로우 페이지는 기본 페이지와 마찬가지로 단편화가 발생할 수 있고 새로운 데이터를 쓰기 위해 공간을 회수하거나 필요없는 페이지를 삭제해야 한다. 
- 첫 오버플로우 페이지를 할당할 때에는 해당 페이지의 ID를 기본 페이지의 헤더에 저장한다. 오버플로우 페이지가 하나로는 충분하지 않아 여러 개가 되는 경우에는 각 헤더에 다음 페이지 ID를 저장하고 연결한다. 따라서 특정 데이터를 찾기 위해 여러 오버플로우 페이지를 확인해야 할 수 있다.



## 이진 검색

- 트리의 노드에서 특정 키는 이진 검색 알고리즘을 사용해 찾을 수 있다.
- 이진 검색 알고리즘은 정렬된 배열과 검색 키를 인자로 받고 숫자를 반환한다. 양수라면 이 값은 배열에서의 위치를 의미하고 음수라면 해당 키는 배열에 없고 반환 값은 삽입 위치를 의미한다.
- 삽입 위치는 검색 키보다 첫 번째로 큰 값의 위치다. 삽입시에는 삽입 위치 이후 모든 원소를 한 자리씩 이동시켜 새로운 값을 위한 공간을 만들고 삽입한다.
- 검색 키보다 큰 첫번째 값을 찾고 해당 서브트리를 가리키는 포인터를 따라가는 탐색 경로가 중요하다.



### 간접 포인터를 사용한 이진 검색

- B-트리 페이지의 셀은 삽입 순서대로 저장되며 셀 오프셋만 논리적 순서를 유지한다.
- 페이지 셀의 이진 검색은 먼저 중간 셀 오프셋을 선택하고 해당 위치의 키와 검색 키를 비교해 왼쪽과 오른쪽 중 진행 방향을 결정한다.

 ![4-6](https://github.com/sup2is/dev-note/raw/master/db//images/database-internals/4-7.jpeg)





## 분할과 병합

- 노드의 분할과 병합은 상위 레벨까지 전파될 수 있다 따라서 분할하는 리프 노드나 병합하는 두 리프 노드로부터 루트 노드까지 순회할 수 있어야 한다. 
- 하위 레벨의 페이지는 항상 바로 위 레벨을 통해서 참조되기 때문에 부모 노드에 대한 정보는 디스크에 저장하지 않아도 된다.
- 형제 포인터와 마찬가지로 부모 포인터도 부모가 변경되면 알맞게 갱신해야 한다.
- 일부 트리 구현에서는 형제 포인터 사용으로 인해 발생할 수 있는 데드락을 제거하기 위해 리프 노드 탐색에 부모 포인터를 사용하기도 한다.
- 부모 노드에서부터 재귀적으로 포인터를 따라 내려가면 형제 노드를 찾을 수 있다. 같은 부모를 공유하는 모든 형제 노드를 순회하고 난 후에는 재귀적으로 상위 레벨로 올라가 검색을 계속한다. 그러다보면 결국 루트 노드에 도달하고 또 다시 리프 레벨까지 내려가게 된다.



### 탐색 경로

- 부모 포인터를 저장 및 유지하는 대신 리프 노드까지의 경로를 저장해두고 노드 삽입과 삭제로 인해 분할 및 병합이 발생했을 때 저장된 경로를 역순으로 순회하는 방법도 있다.
- B-트리의 구조를 변경하기 위해서는 루트에서 리프 노드 또는 삽입 지점까지 트리를 순회해야 한다. 리프 노드에 도달하기 전에 분할 또는 병합의 발생 여부를 미리 알 수 없기 때문에 탐색 경로를 저장해야 한다.
- 탐색 경로는 루트부터 방문한 모든 노드에 대한 정보를 포함한다. 이러한 정보는 분할 또는 병합이 상위 레벨로 전파될 때 노드를 거슬러 올라가는데 쓴다.
- 노드가 분할되거나 병합되는 경우 저장된 탐색 경로를 이용해 부모 노드로 승급된 키의 삽입 지점을 찾고 필요하다면 더 상위 레벨 노드까지 차례대로 방문하면서 구조를 변경한다. 경로를 저장한 스택은 메모리에 유지한다.

![4-6](https://github.com/sup2is/dev-note/raw/master/db//images/database-internals/4-8.jpeg)

- 루트에서 리프 노드까지 방문한 노드를 가리키는 포인터와 해당 셀의 인덱스가 포함된 탐색 경로를 수집하는 과정
- 리프 노드를 분할해야 한다면 스택의 최상위 요소를 참조해 부모 노드를 찾을 수 있다. 부모 노드에 공간이 남아 있다면 탐색 경로에 저장된 셀 인덱스 위치에 새로운 셀을 추가한다. 만약 공간이 부족하다면 부모 노드도 분할해야 한다. 루트 노드에 도달해 스택에 더 이상 요소가 없거나 분할하지 않아도 될 때까지 이 과정을 반복한다.



## 리밸런싱

- 일부 B-트리 구현에서는 분할과 병합 비용을 줄이기 위해 레벨 내에서 노드를 리밸런싱하거나 분할 및 병합 작업을 수행하기 전에 상대적으로 빈 공간이 많은 노드로 원소를 이동한다. 이 경우 리밸런싱 비용이 높아질 수도 있지만 노드의 점유율을 높이고 트리의 높이는 낮출 수 있다.
- 노드 삽입과 삭제 시 로드 밸런싱을 수행하는 방법도 있다.
- 효율적인 공간 활용을 위해 노드를 분할하는 대신 형제 노드로 일부 원소를 옮기고 삽입할 공간을 확보한다. 삭제 작업도 마찬가지로 형제 노드와 병합하는 대신 노드가 절반 이상 찬 상태를 유지하도록 형제노드에서 일부 원소를 가져올 수 있다.
- B*-트리는 형제 노드가 모두 가득 찰 때까지 이웃 간에 원소를 분산한다.
- B*-트리 알고리즘은 노드를 절반이 비어 있는 두 개의 노드로 분할하는 것이 아니라 두 노드를 2/3가 채워진 3개의 노드로 분할한다. SQLite에서 사용하는 알고리즘이다. 이 방식은 분할을 지연시켜 평균 점유율을 높일 수 있지만 상태를 관리하는 로직이 추가로 필요하다. 높은 점유율로 인해 트리 높이가 낮아지고 순회 시 참조하는 페이지 수가 줄어들면 검색의 효율성도 높아진다.

![4-9](https://github.com/sup2is/dev-note/raw/master/db//images/database-internals/4-9.jpeg)

- 리밸런싱은 많은 데이터베이스 구현에서 사용되는 유용한 기술이다.



## 오른쪽 추가 기법

- 많은 데이터베이스 시스템에서 자동 증가 값을 기본 인덱스로 사용하는데 이 방식을 사용하면 모든 삽입이 인덱스 끝에서만 발생하기 때문에 대부분의 노드 분할 작업이 각 레벨의 가장 오른쪽 노드에서 일어나게 된다. 
- 삽입하는 키가 가장 오른쪽 페이지의 첫 번째 키보다 크고 가장 오른쪽 페이지에 새로운 키를 삽입할 공간이 충분하면 탐색 과정을 건너 뛰고 캐시된 페이지의 알맞은 위치에 키를 바로 삽입한다. PostgreSQL은 이와 같은 방식을 패스트패스라고 부른다.
- SQLite도 퀵밸런스라는 비슷한 개념을 사용한다.

### 벌크 로딩

- 정렬된 데이터를 벌크 로딩하거나 트리를 재구성할 때에는 우측 추가 알고리즘을 사용할 수 있다.
- 데이터가 이미 정렬돼 있기 때문에 벌크 로딩 시 트리의 가장 오른쪽에만 데이터를 추가하면 된다.
- 이 경우에는 트리를 하위 레벨부터 상향식으로 한 레벨씩 구성하거나 상위 레벨 노드에 충분한 수의 포인터를 넣을 수 있을 만큼 하위 레벨의 노드가 추가됐을 때 상위 노드를 쓰는 방식으로 트리를 구성하면 노드의 분할과 병합을 피할 수 있다.
- 미리 정렬된 데이터를 리프 레벨에 페이지 단위로 저장하는 방식으로 벌크 로딩을 구현할 수도 있다.
- B-트리는 항상 최하위 레벨부터 상향식으로 구성하기 때문에 상위 레벨을 만들기 전에 리프 레벨 전체를 먼저 구성할 수 있다. 그렇기 때문에 상위 레벨을 구성하는 시점에는 이미 모든 자식 포인터가 준비돼 있다. 이 방식은 디스크에서 분할이나 병합을 할 필요가 없고 트리를 구성할 때 트리의 최소한의 부분만 메모리에 저장하면 된다는 장점이 있다.
- 불변 B-트리도 같은 방식으로 만들 수 있는데 수정이 불가능하기 때문에 추가적인 공간 오버헤드가 발생하지 않아 점유율과 성능이 향상된다.



## 압축

- 원시 데이터를 압축하지 않고 저장하면 상당한 저장 오버헤드가 발생하기 때문에 대부분의 데이터베이스는 공간을 절약할 수 있는 압축 알고리즘을 제공한다.
- 압축 알고리즘에서 접근 속도와 압축률은 반비례 관계다. 압축률이 높을수록 데이터 크기는 감소하지만 더 많은 자원을 소모해야한다.
- 파일 전체를 압축하면 비효율적이기 때문에 파일 전체가 아닌 페이지 단위로 압축하는게 알맞다.
- 페이지는 다른 페이지와 독립적으로 압축 및 압축 해제할 수 있기 때문에 페이지 로딩 및 플러시와 같이 수행할 수 있다. (파일 전체는 파일 단위로 압축, 해제를 해야함)
- 일반적으로 데이터 전송이 블록 단위로 이뤄지기 때문에 압축된 페이지가 블록의 극히 일부분을 차지하는 경우에는 실제 데이터보다 더 많은 바이트를 읽는 비효율적인 상황이 발생한다.

![4-10](https://github.com/sup2is/dev-note/raw/master/db//images/database-internals/4-10.jpeg)

- (a)를 가져올 때는 다른 페이지의 일부분도 포함이되고 (b)를 요청할 때는 여러 페이지를 요청해야 한다.
- 압축 라이브러리를 선택할 때는 메모리 오버헤드, 압축 성능, 압축 해제 성능, 압축률을 중점적으로 비교해야 한다.



## 정리와 유지

- 지금까지 본 B-트리를 정리하면 B-트리는 데이터 무결성 유지와 공간 회수, 오버헤드 최소화, 페이지 정렬 등의 다양한 작업이 쿼리 수행과 더불어 수행된다.
- 추가로 내부 노드의 분할과 병합, 리프 레벨 노드에 대한 삽입 및 업데이트, 삭제 등이 계속 일어나면 단편화가 발생해 논리적 공간은 충분하지만 연속된 물리적 공간이 부족한 페이지가 생긴다 (단편화)

![4-10](https://github.com/sup2is/dev-note/raw/master/db//images/database-internals/4-11.jpeg)



### 업데이트와 삭제로 인한 단편화

- 삭제된 리프 레벨의 셀은 헤더에서 오프셋만 제거하고 실제 셀은 남겨둔다. 해당 셀은 더이상 참조할 수 없으며 관련 데이터는 쿼리 대상에서 제외된다.
- 페이지가 분할되면 페이지의 일부는 더 이상 참조할 수 없기 때문에 해당 오프셋은 삭제된다. 삭제된 오프셋의 셀은 새로운 데이터로 덮어쓰거나 정리 단계에서 가비지 컬렉터가 처리한다.
- 일부 데이터베이스는 MVCC를 위해 바로 삭제하지 않고 가비지 컬렉션을 수행한다. 해당 셀을 아무런 스레드도 사용하고 있지 않을 때 셀을 정리한다.
- 삭제된 셀의 오프셋만 삭제하고 다른 셀을 재배치하거나 공간 확보를 위해 물리적으로 셀을 삭제하지 않기 때문에 사용 가능한 바이트가 페이지에 흩어져 있을 수 있다. 이와 같은 현상을 단편화라고 하며 이는 제거해야 하는 현상이다.
- 일반적으로 데이터를 삽입하려면 셀 크기에 맞는 연속된 바이트 블록이 필요하다. 단편화된 여러 조각을 모아 연속된 공간을 확보하려면 페이지를 재구성해야 한다.

### 페이지 단편화

- 공간 회수 및 페이지를 재구성하는 과정을 컴팩션, 정리 또는 유지보수라고 한다. 페이지에 사용 가능한 물리적 공간이 부족한 경우 컴팩션과 쓰기를 동시에 수행할 수 있다.
- 컴팩션은 데드셀이 차지하는 공간을 회수하고 셀을 논리적 순서로 재정렬한다. 재구성된 페이지는 파일에서의 위치가 변경될 수 있다.



## 요약

- B-트리 구현과 관련된 몇 가지 주제
  - 페이지 헤더: 헤더에 저장되는 정보
  - 가장 오른쪽 포인터: 구분 키와 쌍이 아닌 포인터를 처리하는 방법
  - 하이 키: 노드에 저장할 수 있는 최대 키
  - 오버플로우 페이지: 사이즈가 큰 가변 길이 레코드를 고정 사이즈 페이지에 저장하는 방법
- 루트 노드에서 리프 노트까지 트리 순회와 군련된 주제
  - 간접 포인터를 사용한 이진 검색
  - 부모 포인터와 탐색 경로를 사용해 탐색 경로를 저장하는 방법
- 트리 최적화 기법, 유지보수 방법
  - 리밸런싱: 분할과 병합 횟수를 줄이기 위해 이웃 노드로 일부 요소를 이동
  - 오른쪽 추가 기법: 새로운 데이터가 빠르게 삽입될 때 셀을 분할하는 대신 데이터를 트리의 가장 오른쪽 셀에 추가하는 방법
  - 벌크 로딩: 정렬된 데이터를 사용해 B-트리 효율적으로 구성하는 방법
  - 가비지 컬렉션: 페이지를 재구성하고 키 순으로 셀 정렬 및 사용하지 않는 셀의 공간을 회수하는 작업
