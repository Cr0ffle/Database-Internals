# #8 분산 시스템 개요

## 동시 수행

```
int x = 1;
x += 2;
x *= 2;

// result = 6
```

- 단일 스레드 프로그램
  - 여러 변수와 수행 프로세스를 정의할 수 있다. 이 과정에서 race-condition이 발생하지 않는다.
- 멀티 스레드 프로그램
  - 두 개의 스레드가 같은 변수를 동시에 요청했을 때 스레드간 수행 순서를 맞추지 않는 이상 결과를 예측할 수 없다. (race-condition)
  - 멀티 스레드 프로그램에서의 동시성 관련 시나리오
  - ![image-20220616203639074](https://github.com/sup2is/dev-note/raw/master/db/images/database-internals/8-1.png)
    1. 두 스레드가 모두 같은 초깃값을 읽어서 발생하는 문제
    2. 특정 스레드가 수행되기 전에 다른 스레드가 결과를 수행하는 문제



- 동시성을 지원하는 프로그램의 특징
  - 분산 시스템의 성격을 가진다.
  - 스레드는 공유된 자원에 접근하고 개별적으로 연산을 수행한 뒤 결과를 다시 공유 변수에 쓴다.
  - 수행 단계를 정확하게 정의하고 가능한 결과의 수를 줄이기 위해 일관성 모델이 필요하다.
- 분산 시스템의 특징
  - 프로세서별 상태가 다르다.
  - 프로세스끼리는 메시지 교환을 통해 통신한다.



- 동시성과 병렬성의 차이 by 조 암스트롱 (erlang 창시자)
  - 동시성 : 한 대의 커피머신에 두 줄을 세우는 것
  - 병렬성 : 두 대의 커피머신에 두 줄을 세우는 것
  - 일반적으로 병렬성이라는말은 잘 사용하지 않고 통틀어서 동시성이라는 단어를 사용한다.

### 분산 시스템의 자원 공유

- 분산 시스템에서는 데이터 저장소를 공유 메모리처럼 사용할 수 있다. 하지만 데이터베이스의 대한 동시 요청 문제를 해결한다고 하더라도 모든 프로세스의 동기화를 보장할 수 없다.
- 발생할 수 있는 장애 모델들 정의하기
  - 먼저 분산 시스템에서는 장애의 원인을 정확하게 알 수 없다. 이는 분산 시스템 장애의 특성이다.
  - ex: 특정 프로세스가 데이터베이스로부터 오랜 시간 응답을 받지 못할 때 예측 가능한 오류
    1. 데이터베이스의 과부하
    2. request가 네트워크 이슈로 데이터베이스에 도달하지 못했을 때
    3. request가 정상적으로 데이터베이스에 도달해서 응답을 처리했으나 response를 받지 못했을 때
  - 이런 장애를 해결할 수 있는 방법을 찾기 전에 장애 유형을 나타내는 장애 모델을 정의해야 한다.
- 내결함성이란?
  - 시스템의 신뢰성과 장애 발생 시 정상적으로 작동할 수 있는지 여부를 나타내는 속성
  - 우선 신뢰할 수 있는 컴포넌트로 시스템을 구성하고 단일 노드 데이터베이스와 같은 형태의 단일 장애 지점(spof)을 제거해야 한다. ex: replication(복제), redundancy(다중화)

## 분산 컴퓨팅의 오류

- 네트워크 이슈
  - 일반적인 상황에서 두 대의 컴퓨터는 네트워크를 통해 신뢰할 수 있는 통신을 할 수 있고 이런 가정은 합리적이다. 그러나 100프로 성공한다는 가정은 위험하다.
  - 요청이나 응답은 네트워크상에서 충분히 유실될 수 있다. 따라서 네트워크상에서 나타날 수 있는 이슈들을 대처할 수 있는 시스템을 구축해야 한다.

### 프로세싱

- 원격 프로세싱의 오해
  - 원격 프로세스의 로컬 프로세싱도 즉각적이지 않기 때문에 네트워크 레이턴시를 고려하는 것도 충분하지 않다.
  - 메시지가 전달되는 즉시 프로세싱이 시작된다는 보장도 없다. (ex: 이전 작업을 처리하고 있는 경우)
  - 노드는 물리적으로 위치가 가깝거나 멀 수 있고 (네트워크) CPU의 종류와 RAM의 크기 등등 하드웨어 및 소프트웨어 버전과 환경이 다를 수 있기 때문에 모든 노드의 요청 처리 속도가 같다고 보장할 수도 없다.
- 큐잉 시스템과 처리량
  - 기대와는 다르게 큐의 용량은 제한적이고 요청을 계속해서 쌓는 것은 시스템에 아무런 도움이 안된다. 백프레셔로 프로듀서의 발행 속도를 의도적으로 낮출 수 있지만 메시지 소비 속도와는 연관이 없다
  - 대개 큐의 용량을 늘리면 파이프라이닝과 병렬화를 돕고 요청을 효율적으로 스케줄링 할 수 있을거라고 생각하지만 큐의 용량과 프로세싱 속도는 전혀 연관이 없다. 오히려 레이턴시만 증가한다.
  - 일반적으로 프로세스에서 로컬 큐를 사용하는 이유
    - 분리: 메시지 수신과 처리를 시간적으로 분리하고 독립적으로 수행하기 위해
    - 파이프라이닝: 서로 다른 단계에 있는 요청은 각각 독립된 서브 시스템이 처리한다.
    - 일시적 급증 부하 처리: 요청이 실패했다고 응답하고 재시도하는 것 보다 시스템에서 어느정도의 레이턴시가 있는게 낫다.
- 큐의 적절한 크기 구하기
  - 기본적으로 큐의 크기는 작업량과 애플리케이션 별로 다르다.
  - 작업량이 비교적 일정하다면 작업 처리 시간과 작업이 처리되기 전까지 큐에서 머무르는 평균시간을 측정해서 큐의 크기를 조정한다.
  - 처리량은 늘리고 레이턴시는 허용 가능한 범위 내로 유지해야 한다.
  - 작업량을 예측할 수 없고 대량의 작업이 동시에 요청된다면 큐의 크기를 높은 부하와 요청 수를 감당할 수 있을 정도로 조정해야 한다.

## 클럭과 시간

- 로컬 클럭과 분산시스템
  - 분산 시스템에서 두 서버의 클럭이 동기화됐다는 가정은 위험할 수 있다.
  - 메시지가 정확한 시간을 제공한다고 완전히 보장하지 않는 이상 동기화 또는 순서화에 타임스탬프를 사용하면 안된다.
  - 모든 동기 시스템의 타임아웃은 로컬 클럭에 의존한다.
- 분산 시스템에서 클럭 동기화는 쉽지 않다는 사실 외에도 현재 시간은 항상 바뀐다는 점을 기억해야 한다.
- 클럭이 단조 클럭인지 여부와 예정된 시간 관련 작업 사이에 시간 차이가 얼마나 발생할 수 있는지 아는 것은 많은 도움이 될 수 있다.

### 상태 일관성

- 분산 시스템의 일관성
  - 복잡하지 않게 생각해도 된다면 일부 특수한 상황은 무시하고 특정 방법으로 생각하면 모델을 단순화할 수 있다.
  - 분산 알고리즘은 상태에 대한 일관성을 완벽하게 보장하지 않는다. 노드간의 상태 차이를 허용하거나 충돌해결과 읽기 중 데이터 복구 방식을 통해 상태차이를 해결한다.
  - 결과적 일관성을 보장하는 분산 시스템에는 읽기 중에 노드의 정족수만큼 쿼리해 노드 사이의 상태 불일치를 해결하는 로직이 있을 수 있다.
- 분산 시스템에서 이러한 오류에 대해 완전한 해결책을 구현하는 것이 어렵더라도 발생할 수 있는 문제에 대해 미리 생각해두는 것이 좋다. 문제를 이해하면 시스탬 내에 안전장치를 설치하거나 해결책에 맞도록 설계를 변경할 수 있을 것이다.

### 로컬 실행과 원격 실행

- 원격실행과 로컬실행의 가장 큰 차이는 네트워크 사용 유무다. (레이턴시) 원격실행은 네트워크 전송, 직렬화/역직렬화 등등의 여러 단계가 추가되기 때문에 비용이 높다.

### 장애 처리

- 100% 안전한 시스템은 없다.
  - 모든 노드가 정상적으로 작동한다고 가정하고 시스템 설계를 시작하는 것도 괜찮지만 항상 이렇게 가정하는 것은 위험하다.
  - 하드웨어, 소프트웨어 문제 등으로 인해 노드에 장애가 발생할 수 있다.
  - 장애 상황에 대비하고 어떻게 대처할 수 있을지 고민해야 한다.

### 네트워크 파티션과 부분 장애

- 네트워크 파티션이란?
  - 2개 이상의 서버가 서로 통신할 수 없는 상황을 네트워크 파티션이 발생했다고 말한다.
  - 이런 네트워크 파티션은 데이터 일관성이 깨지는 상황이 발생할 수 있어 심각한 문제다.
- 가용성
  - 한 개 이상의 프로세스에 장애가 발생해도 정상 작동하는 견고한 시스템을 구축하기 이해서는 부분적인 장애 상황에 대비해야 한다.
  - 시스템 일부분에 접근할 수 없거나 기능에 문제가 생겨도 시스템은 계속해서 동작해야 한다.
  - [CAP 이론](https://en.wikipedia.org/wiki/CAP_theorem)
- 장애 테스트
  - 모든 장애를 예방하는 것은 불가능하지만 장애가 발생해도 정상적으로 작동하는 탄력적인 시스템을 구축할 수 있다.
  - 장애에 대처하는 가장 이상적인 방법은 테스트다.
  - 모든 장애 시나리오를 검토하고 여러 프로세스의 동작을 예측하는 것은 불가능하지만 분산 시스템은 가능한 많은 시나리오를 포함해야 한다.
  - https://github.com/Netflix/chaosmonkey
- 분산 시스템 설계 시 내결함성, 회복력, 장애 시나리오 그리고 여러 특수 상황을 모두 신중하게 고려해야한다.

### 계단식 장애

- 계단식 장애
  - 특정 프로세스의 사용량이 급증하면 결국 클러스터 전체의 사용량이 증가해 다른 노드에도 장애가 발생할 수 있다.
  - 계단식 장애는 시스템의 한 부분에서 다른 부분으로 전파돼 오류의 범위를 확장한다.
  - 이런 계단식 장애를 방지하기 위해 소프트웨어 시스템에도 circuit breaker를 사용하기도 한다.
  - 계단식 장애는 우호적인 의도에서 비롯될 수도 있다.
    - ex: 어떤 노드가 장애로 인해 종료되었다가 다시 클러스터에 진입한 순간 그 사이에 발생한 데이터 sync를 위해 노드간 사용량이 급증하는 case
- 백오프 전략
  - 특정 서버와의 연결이 끊어지거나 서버가 응답하지 않는 경우 클라이언트는 계속해서 서버에 연결을 시도한다. 이 때 서버는 새로운 요청을 받아주느라 너무 바빠진다.
  - 이런 상황을 방지하기 위해 클라이언트는 바로 재시도하지 않고 잠시 대기하는 백오프 전략을 사용한다.
- 지터
  - 여러 클라이언트가 만약 동일한 백오프 전략(시간?) 을 사용할 경우 상당한 부하가 발생할 수 있다. 이런 상황을 방지하기 위해 지터를 사용하기도 한다.
  - 지터는 백오프 기간에 임의의 짧은 시간을 추가해 여러 클라이언트가 동시에 재시도하는 확률을 줄인다.
- 유효성 검증 메커니즘
  - 레코드의 유효성 검증이 없으면 손상된 데이터가 다른 노드로 복제될 수 있다.
  - 이와 같은 문제는 체크섬, 유효성 검증을 통해 노드 사이에 교환되는 데이터의 무결성을 확인해야 한다.
- 권고사항
  - 부하와 핫스팟은 작업을 미리 계획하고 조정함으로써 방지할 수 있다.
  - 분리된 작은 문제를 처리하는 것이 대규모 장애를 복구하는 것보다 훨씬 간단하다.
  - 어떤 문제가 생길 수 있는지 예상하고 세심하게 설계하고 테스트하면 더욱 견고하고 탄력적인 시스템을 만들 수 있다.

## 분산 시스템 추상화

- 분산 시스템에서 사용하는 공통 용어
  - 링크
  - 두 장군 문제
  - FLP 불가능성 이론
  - 시스템 동기성

### 링크

- 네트워크는 신뢰성이 낮다. 메시지는 분실 또는 지연될 수 있고 순서가 바뀔 수 있다.

**손실될 수 있는 링크**

[![image-20220617000001180](https://github.com/sup2is/dev-note/raw/master/db/images/database-internals/8-2.png)](https://github.com/sup2is/dev-note/blob/master/db/images/database-internals/8-2.png)

- 이 상황에서 메시지 M의 상태로 가능한 것들
  - 아직 프로세스 B에 전달되지 않음
  - 전송 중에 손실돼 복구가 불가능함
  - 원격 프로세스에 성공적으로 전달됨
- 손실 허용 링크와 속성
  - 위 그림과 같은 방식에서 송신자는 메시지 전달 여부를 확인할 수 없다. 분산 시스템에서는 이를 손실 허용 링크라고 부른다.
  - 손실 허용성
    - 송신자와 수신자가 정확하다면 송신자가 무한정 재전송한 메시지는 결과적으로 전달된다.
  - 유한 중복성
    - 메시지는 무한히 중복 전달되지 않는다.
  - 생성 불가성
    - 링크는 메시지를 생성하지 않는다. 즉 전송되지 않은 메시지가 전달될 수 없다.
- 손실 허용 링크는 유용한 추상화이며 보장성이 높은 통신 프로토콜의 중요한 구성 요소다.
- 손실 허용 링크는 UDP와 유사하다.

**메시지 확인 응답**

- 손실 허용 링크 개선하기
  - 손실 허용 링크에서 발생할 수 있는 문제들을 개선하기 위해 수신자가 메시지를 수신했음을 알리는 메시지 확인 응답을 사용할 수 있다.
  - 개선하기 위해서는 양방향 통신 채널과 메시지를 구별할 수 있는 어떤 수단이 필요하다.
  - [![image-20220617001631827](https://github.com/sup2is/dev-note/raw/master/db/images/database-internals/8-3.png)](https://github.com/sup2is/dev-note/blob/master/db/images/database-internals/8-3.png)
  - n이 단조증가하는 메시지 카운터를 나타낼 때 프로세스 A는 메시지(n)을 전송하고 메시지를 받은 B는 확인 응답ACK(n)을 A에게 보낸다. 확인 응답도 마찬가지로 전송 중에 손실될 수 있다

**메시지 재전송**

- 메시지 재전송하기
  - 응답 메시지가 손실되는 경우가 있기 때문에 확인 응답을 추가하는 것만으로 통신 프로토콜을 완전히 신뢰할 수는 없다.
  - 이와 같은 문제를 해결하기 위해 메시지를 재전송할 수 있다.
- 스터번 링크
  - 네트워크 문제가 무한히 발생하는 상황이 아니라고 가정하면 송신자의 관점에서 메시지는 B에 성공적으로 전달되지 못한 상태다.
  - 이 때 송신자A는 계속해서 메시지를 재전송한다 이를 스터번 링크(stubborn: 고집스러운)라고 부른다.
  - 스터번 링크는 매우 비효율적이기 때문에 확인 응답과 재시도를 같이할 수 있는 방법이 필요하다.

**재전송 문제**

- 모든 요청이 멱등한가?
  - 멱등 연산은 여러 차례 수행해도 부작용이 없고 결과가 동일한 연산이다.
  - 만약 모든 연산이 멱등적이라면 메시지 재전송에 대해 복잡하게 생각하지 않아도 된다. 하지만 모든 연산이 멱등적이지 않다. (ex: 결제 시스템)
  - 따라서 작업의 의미를 바꾸지 않고 멱등성에 준하는 결과를 보장하는 방법이 필요하다. 이를 위해 중복 제거 기능을 사용하면 메시지를 중복 처리하는 것을 방지할 수 있다.

**메시지 순서**

- 신뢰성이 낮은 네트워크의 두가지 문제
  - 메시지가 전송 순서대로 도착하지 않는다
  - 재전송으로 인해 같은 메시지가 여러번 전송될 수 있다.
- 시퀀스를 사용하면 수신자는 순서를 유지할 수 있다.
  - n(consecutive) : 수신한 메시지의 가장 높은 시퀀스 번호. 이 번호까지의 메시지는 다시 실제 순서대로 정렬할 수 있다.
  - n(processed) : 실제 순서대로 정렬하고 처리한 메시지의 가장 높은 시퀀스 번호. 중복 제거 용도로 사용된다.
  - 메시지의 순서가 비연속정인 경우 시퀀스를 사용해서 판단하고 버퍼에 임시로 저장한 뒤에 다시 정렬해서 실제 순서를 재구성할 수 있다.
  - 중복 제거 작업은 시퀀스 n의 처리 여부를 확인하고 이미 처리된 메시지는 삭제할 수 있다.
- 퍼펙트 링크
  - 분산 시스템에서 이런 링크를 퍼펙트링크라고 부르며 다음 속성을 보장한다.
    - 전송 신뢰성: 정상적인 프로세스 A와 B 사이에 한 번 전송된 모든 메시지는 결국 전달된다.
    - 전송 비중복성: 메시지는 한 번만 전달된다.
    - 생성 불가성: 다른 종류의 링크와 마찬가지로 오직 실제로 전송된 메시지만 전달될 수 있다.

**정확히 한 번 전달**

- 메시지 전달 방법
  - exactly-once-delivery: 정확히 한 번만 전달 -> 가장 이상적이지만 이론적으로 불가능하다.
  - at-least-once-delivery: 최소 한 번 전달 -> 대부분의 시스템이 이 방법을 사용, 결국 응답을 받지 못하면 실패로 간주
  - at-most-once-delivery: 최대 한 번 전달 -> 메시지를 전송한 뒤 전달 여부는 신경쓰지 않는다.
- TCP는 과연 안전한가?
  - TCP는 일부 패킷을 재전송할 수 있고 같은 패킷의 전송 시도가 여러 차례 성공할 수 있다. 이 패킷에는 시퀀스 번호가 있기 때문에 수신자는 중복 패킷을 제거할 수 있다.
  - 하지만 위에서 설명한 TCP의 특징은 오직 단일 세션에서만 유효한 속성이다.
  - 수신자는 메시지를 확인 및 처리했지만 송신자가 확인 응답을 받기 전에 연결이 끊어지면 애플리케이션은 전달 여부를 알 수 없다.
- 모든 메시지를 한 번만 전송하는 100% 신뢰할 수 있는 링크는 존재하지 않는다. 하지만 모든 메시지를 한 번만 처리하고 중복된 메시지는 무시하면 송신자의 관점에서 정확히 한 번 전달된 것과 같이 보이게 할 수 있다.

### 두 장군 문제

- 두 장군 문제
  - 두 명의 장군이 특정 요새를 공격하려고 하는데 둘 모두의 동의가 이뤄져야 한다.
  - 장군 A가 장군 B에게 공격을 위한 MSG(N)를 보낸다. 이 메시지는 B에게 가는 동안 유실될 수 있다.
  - 만약 장군 B가 MSG(N)을 받는다 하더라도 장군 A에게 ACK(MSG(N)) 응답을 보내야한다. 이 응답은 장군 A에게 가는 동안 유실될 수 있다.
  - 장군 A가 ACK(MSG(N))를 받는다. 이때까지도 장군B는 장군A가 ACK(MSG(N))를 받았는지 정확하게 모르기때문에 ACK(ACK(MSG(N))) 를보낸다. 이 응답 메시지는 유실될 수 있다.

![](https://github.com/sup2is/dev-note/raw/master/db/images/database-internals/8-4.png)

### FLP 불가능성 이론

- Fisher, Lynch, Paterson이 공동 저술한 FLP 불가능성 이론
  - 이 이론은 초깃값을 가진 여러 프로세스가 새로운 값에 대해 합의하는 과정을 설명한다.
  - 알고리즘이 완료된 후 모든 정상 프로세스의 최신 값은 같아야 한다.
  - 하지만 실제 시스템에서는 다양한 네트워크 문제나 프로세스 속도 저하 및 충돌 등 다양한 형태의 장애가 발생한다.
- 정상적인 합의 프로토콜의 세가지 속성
  - 일치성: 프로토콜의 결과는 모두가 동의해야 한다. 일치하지 않으면 합의는 실패한다.
  - 유효성: 결정된 값은 특정 프로세스가 제안한 값이다.
  - 유한성: 합의는 오직 모든 프로세스가 확정된 상태가 됐을 때 유효하다.
- 비동기 시스템에서는 모든 프로세스의 처리 속도는 알 수 없고 항상 한정된 시간 내에 메시지를 전달하거나 전달 순서를 보장할 수 없다.
- FLP 불가능성 이론은 (비동기 시스템에서) 한정된 시간 내에 합의가 반드시 이뤄지는 프로토콜은 존재하지 않는다고 주장한다.

### 시스템 동기성

- 비현실적인 가정
  - 실제로 일반적인 프로세스 사이의 처리 속도 차이는 크지 않고 링크를 통해 메시지를 전달하는데 시간이 무한정 오래 걸리지 않는다. (심지어 데이터 유실도 ..)
  - 시간에 의존하면 문제 파악이 간단해지고 보장할 타이밍을 제한할 수 있다.
  - 하지만 여전히 일부 비동기 모델의 합의 문제는 해결이 어려울 수 있다. 그리고 문제의 가장 실용적인 해결방안은 시간에 의존할 가능성이 높다.
- 동기 모델 기반 시스템
  - 동기 모델 기반의 시스템에서는 타임아웃을 통해 리더 선출, 합위, 장애 감지와 같은 더 복잡한 추상화를 구현할 수 있다.
  - 동기성은 분산 시스템에서 매우 중요한 속성이다.
- 동기 모델과 비동기 모델의 속성을 합친 모델을 부분 동기 모델이라고 한다.

## 장애 모델

### 충돌

- 프로세스 충돌과 충돌-정지 모델
  - 가장 단순한 프로세스 충돌은 프로세스가 알고리즘 수행을 중단하고 다른 프로세스에 더 이상 메시지를 보내지 않는 경우다.
  - 대부분 충돌한 프로세스는 충돌 상태를 유지한다고 규정하는 충돌-정지 모델을 기본 모델로 정의한다.
  - 충돌-정지 모델은 프로세스가 복구될 수 없다는 것을 의미하지 않으며 복구를 시도하지 않 거나 막지 않는다.
  - 프로세스는 장애가 지속되는 동안에는 합의 과정에 참여할 수 없다. 복구된 프로세스는 시스템 상태와 동기화하고 다음 알고리즘 수행에 참여한다.
- 충돌-복구 모델
  - 알고리즘 수행 중 중단된 프로세스는 복구시 남은 단계를 계속해서 수행한다.
  - 프로세스를 복구하려면 상태의 개념과 복구 프로토콜이 필요하다.
  - 충돌-복구 모델 기반의 알고리즘은 모든 가능한 복구 상태를 고려해야 한다. 복구된 프로세스는 중단되기 전에 마지막으로 실행한 단계부터 재시도할 수 있기 때문이다.
  - 프로세스의 관점에서 연결이 끊어졌던 프로세스와 장애 발생 후 복구된 프로세스를 구분할 수 없기 때문에 충돌-복구 모델은 일종의 누락 장애 모델로 볼 수 있다.

### 누락

- 누락 장애 모델
  - 누락은 알고리즘의 일부 단계를 건너뛰거나 수행결과를 확인할 수 없을 때 발생한다.
  - 네트워크 링크 및 스위치 고장, 네트워크 정체 등으로 인한 네트워크 문제로 인한 누락, 큐 공간 부족 등으로 발생할 수 있다.

### 임의의 장애

- 비잔티움 장애
  - 특정 프로세스가 악의적으로 거짓말을 하거나 제어하는 경우를 비잔티움 장애라고 하고 이 경우엔 시스템이 매우 어려워질 수 있다.
  - 비잔티움 장애는 항공업계에서 자주 사용하는 개념이다. ex: 특정 항공기의 응답을 곧이곧대로 신뢰하지 않고 다른 응답과 교차 검증한다

### 장애 처리

- 프로세스를 여러 그룹으로 나눠 다중화하면 장애 발생 사실을 사용자에게 숨길 수 있다.
- 대부분의 장애는 소프트웨어 코드 리뷰와 광범위한 테스트, 타임아웃과 재시도 그리고 알고리즘 단계의 수행 순서를 보장해 방지할 수 있다.

## 요약

- 링크는 메시지를 전달받지 못할 수 있고 충돌할 수 있으며 네트워크 파티션이 발생할 수 있다. 이와 같은 시스템 컴포넌트의 낮은 신뢰성이 문제를 일으키고 시스템을 더 복잡하게 만든다.